#第五章 java中的锁（使用与实现）

##一、Lock接口

提供了synchronized不具有的特性：

    1.尝试非阻塞地获取锁：tryLock()，调用方法后立刻返回
    2.能被中断地获取锁：lockInterruptibly():在锁的获取中可以中断当前线程
    3.超时获取锁:tryLock(time,unit)，超时返回
    
Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。
    
##二、队列同步器
    
队列同步器AbstractQueuedSynchronizer是用来构建锁或其他同步组件的基础框架。
它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。
理解两者的关系：

    锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；
    同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待
    和唤醒等底层操作。
    
###队列同步器的实现分析

####1.同步队列

通过一个FIFO双向队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息
构造成一个Node并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试
获取同步状态。

首节点是获取同步状态成功的节点，首节点在释放同步状态时，会唤醒后继节点，而后继节点在获取同步状态成功时将自己设置为首节点。

####2.独占式同步状态获取和释放

     public final void acquire(int arg) {
            if (!tryAcquire(arg) &&acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
     }
     
     
     
     
代码分析：
首先尝试获取同步状态，如果获取失败，构造独占式同步节点并将其加入到节点的尾部，
然后调用acquireQueued，使节点一死循环的方式去获取同步状态，如果获取不到就阻塞节点中的线程。

两个死循环：入队、入队后
 
只有前驱节点是头结点才能尝试获取同步状态，原因：

1. 头结点是成功获取到同步状态的节点，而头结点的线程释放了同步状态后，将会唤醒其后继节点，后继节点的线程
被唤醒后需要检查自己的前驱节点是否为头节点。

2. 维护同步队列的FIFO原则


        p128页的图非常重要

    总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，
    移出队列（停止自旋）的条件是前驱节点是头结点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease
    方法释放同步状态，然后唤醒头结点的后继节点
   
   
####3.共享式同步状态获取和释放

主要区别：同一时刻是否有多个线程同时获取到同步状态

    共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞。独占式访问资源时，同一时刻其他访问均被阻塞。
    

##三、重入锁（ReentrantLock）

synchronized关键字隐式地支持重入

ReentrantLock不像synchronized隐式支持，在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。

事实上，公平的锁机制往往没有非公平的效率高，但是公平锁的好处在于：公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到
优先满足。

###1.重入的实现

两个问题：再次获取锁、最终释放

###2.公平锁与非公平锁的区别：

如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO

    公平锁：CAS成功，且是队列的首节点
    非公平锁：CAS成功即可
    
重入锁的默认实现是非公平锁，原因：虽然会导致饥饿，但是非公平锁的的开销少（线程切换次数少），从而可以有更高的吞吐量。

##四、读写锁（ReentrantReadWriteLock）

前文中的锁基本都是排他锁，在同一时刻只允许一个线程访问。

读写所在同一时刻可以允许多个读线程访问，但在写线程访问时，所有读线程和其他写线程均被阻塞。（保证了写操作的可见性）

读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

###读写锁的实现分析

####1.读写状态的设计

依赖自定义同步器，读写锁的自定义同步器需要在同步状态（一个int值）上维护多个读线程和一个写线程的状态，高16位表示读，低16位
表示写。

    位运算
    
####2.写锁的获取与释放

写锁是一个支持重入的排他锁，如果当前线程已经获取了写锁，则增加写状态。
如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。

####3.读锁的获取与释放

在没有其他写线程访问时，读锁总会被成功地获取。如果写锁已经被其他线程获取，则进入等待状态。

读状态的线程安全由CAS保证

####4.锁降级（写锁降级成为读锁）

定义：把持住写锁，再获取到读锁，随后释放写锁的过程

    writeLock.lock();
    readLock.lock();
    writeLock.unlock();

>这边不是很理解。。。。

锁降级中读锁获取的必要性：

    为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程获取了写锁
    并修改了数据，那么当前线程无法感知到数据的更新.如果当前线程获取读锁，则另一个线程会被阻塞，
    直到当前线程使用数据并释放锁之后，另一个线程才能获取写锁进行数据更新。
    
##五、LockSupport工具

略，感觉不是很重要

##六、Condition接口

略，等待通知模式，有空回头再看

    